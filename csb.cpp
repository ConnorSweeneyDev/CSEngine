#include "csb.hpp"

#include <cstddef>
#include <filesystem>
#include <format>
#include <fstream>
#include <ios>
#include <istream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <tuple>
#include <unordered_map>
#include <vector>

void configure()
{
  csb::target_name = "CSEngine";
  csb::target_artifact = EXECUTABLE;
  csb::target_linkage = STATIC;
  csb::target_subsystem = CONSOLE;
  csb::target_configuration = RELEASE;
  csb::cxx_standard = CXX20;
  csb::warning_level = W4;
  csb::include_files = csb::files_from({"program/include"}, {}, {"program/include/resource.hpp"});
  csb::source_files = csb::files_from({"program/source"}, {}, {"program/source/resource.cpp"});
  if (csb::host_platform == WINDOWS)
    csb::libraries = {"kernel32", "user32",   "shell32",  "gdi32",       "imm32", "comdlg32",
                      "ole32",    "oleaut32", "advapi32", "dinput8",     "winmm", "winspool",
                      "setupapi", "uuid",     "version",  "SDL3-static", "glm"};
  else if (csb::host_platform == LINUX)
    csb::libraries = {"c", "m", "pthread", "dl", "SDL3", "glm"};
}

int clean()
{
  csb::clean_build_directory();
  csb::remove_files({"program/include/resource.hpp", "program/source/resource.cpp"});
  return CSB_SUCCESS;
}

int build()
{
  csb::vcpkg_install("2025.08.27");

  csb::archive_install(
    {{csb::host_platform == WINDOWS
        ? "https://github.com/microsoft/DirectXShaderCompiler/releases/download/v1.8.2505.1/dxc_2025_07_14.zip"
        : "https://github.com/microsoft/DirectXShaderCompiler/releases/download/v1.8.2505.1/"
          "linux_dxc_2025_07_14.x86_64.tar.gz",
      "build/dxc",
      {csb::host_platform == WINDOWS ? "bin/" + csb::host_architecture : "bin",
       csb::host_platform == WINDOWS ? "lib/" + csb::host_architecture : "lib"}}});
  if (csb::host_platform == LINUX)
  {
    csb::multi_task_run("chmod +x ()", csb::files_from({"build/dxc"}, {""}), {"build/dxc/executable.(filename)"});
    csb::prepend_environment_variable("LD_LIBRARY_PATH", "build/dxc");
  }
  csb::multi_task_run(
    [](const auto &file, const auto &, const auto &)
    {
      return std::format("{} -spirv -T {}_6_0 -E main () -Fo []",
                         csb::host_platform == WINDOWS ? "build\\dxc\\dxc.exe" : "./build/dxc/dxc",
                         file.extension() == ".vert" ? "vs" : "ps");
    },
    csb::files_from({"program/shader"}), {"build/shader/(filename).spv"});

  using frame_group = std::tuple<std::string, int, int>;
  using texture = std::tuple<int, int, std::vector<frame_group>>;
  std::unordered_map<std::filesystem::path, texture> texture_configs = {};
  std::ifstream config_file("program/texture/config.txt");
  if (!config_file.is_open()) throw std::runtime_error("Could not open texture config file");
  std::string line = {};
  while (std::getline(config_file, line))
  {
    if (line.empty() || line[0] == '#') continue;
    std::istringstream line_stream(line);

    std::filesystem::path path = {};
    line_stream >> path;
    int frame_width = 0, frame_height = 0;
    char colon1;
    line_stream >> frame_width >> colon1 >> frame_height;
    std::vector<frame_group> group_configs = {};
    std::string group_section = {};
    while (line_stream >> group_section)
    {
      std::istringstream group_stream(group_section);
      std::string group_name = {}, group_start = {}, group_end = {};
      std::getline(group_stream, group_name, ':');
      std::getline(group_stream, group_start, ':');
      std::getline(group_stream, group_end);
      group_configs.emplace_back(group_name, std::stoi(group_start), std::stoi(group_end));
    }
    texture_configs.emplace(path, std::make_tuple(frame_width, frame_height, group_configs));
  }
  config_file.close();

  using binary_data = std::vector<unsigned char>;
  using pixel_data = std::tuple<int, int, int, texture>;
  using resource = std::tuple<binary_data, pixel_data>;
  csb::embed<resource>(
    {"// This file is automatically generated, do not edit manually.\n\n"
     "#pragma once\n\n"
     "#include <algorithm>\n"
     "#include <cstddef>\n"
     "#include <span>\n"
     "#include <string_view>\n"
     "#include <utility>\n\n"
     "#include \"utility.hpp\"\n\n"
     "namespace cse::resource\n"
     "{\n"
     "  struct compiled_shader\n"
     "  {\n"
     "    const std::span<const unsigned char> source = {};\n"
     "    const std::size_t length = {};\n"
     "  };\n"
     "  struct compiled_texture\n"
     "  {\n"
     "    struct image_data\n"
     "    {\n"
     "      const unsigned int width = {};\n"
     "      const unsigned int height = {};\n"
     "      const unsigned int channels = {};\n"
     "    };\n"
     "    struct frame_data\n"
     "    {\n"
     "      struct group\n"
     "      {\n"
     "        struct frame\n"
     "        {\n"
     "          struct rect\n"
     "          {\n"
     "            const float top = {};\n"
     "            const float left = {};\n"
     "            const float bottom = {};\n"
     "            const float right = {};\n"
     "          };\n"
     "          const rect coords = {};\n"
     "        };\n"
     "        const unsigned int start_frame = {};\n"
     "        const unsigned int end_frame = {};\n"
     "        const std::span<const frame> frames = {};\n"
     "      };\n"
     "      const group &find_group(std::string_view name) const\n"
     "      {\n"
     "        auto it = std::lower_bound(groups.begin(), groups.end(), name,\n"
     "                                   [](const auto &pair, std::string_view key) { return pair.first < key; });\n"
     "        if (it == groups.end() || it->first != name)\n"
     "          throw utility::exception(\"Could not find '{}' frame group for texture\", name);\n"
     "        return it->second;\n"
     "      };\n"
     "      const unsigned int width = {};\n"
     "      const unsigned int height = {};\n"
     "      const std::span<const std::pair<std::string_view, group>> groups = {};\n"
     "    };\n"
     "    const std::span<const unsigned char> image = {};\n"
     "    const image_data image_data = {};\n"
     "    const frame_data frame_data = {};\n"
     "  };\n\n",
     "// This file is automatically generated, do not edit manually.\n\n"
     "#include \"resource.hpp\"\n\n"
     "#include <array>\n"
     "#include <string_view>\n"
     "#include <utility>\n\n"
     "namespace cse::resource\n"
     "{\n"},
    {nullptr,
     [](const auto &file, const auto &name, const auto &)
     {
       if (file.extension() == ".spv")
         return std::format("  static constexpr std::array<const unsigned char, (1)> {}_data = {{\n    (0)}};\n\n",
                            name);
       else
         return std::format(
           "  static constexpr std::array<const unsigned char, (1)> {}_image = {{\n    (0)}};\n(2)\n\n", name);
     },
     [](const auto &file)
     {
       if (file.extension() == ".spv")
       {
         if (file.stem().extension() == ".vert")
           return file.stem().stem().string() + "_vertex";
         else
           return file.stem().stem().string() + "_fragment";
       }
       else
         return file.stem().string() + "_texture";
     },
     [&texture_configs](const auto &file) -> resource
     {
       if (file.extension() == ".spv")
       {
         binary_data shader_data;
         std::ifstream shader_file(file, std::ios::binary | std::ios::ate);
         if (!shader_file) throw std::runtime_error(std::format("Could not open shader file '{}'", file.string()));
         const std::streamsize size = shader_file.tellg();
         shader_file.seekg(0, std::ios::beg);
         shader_data.resize(static_cast<std::size_t>(size));
         if (!shader_file.read(reinterpret_cast<char *>(shader_data.data()), size))
           throw std::runtime_error(std::format("Could not read shader file '{}'", file.string()));
         return {shader_data, {}};
       }
       else
       {
         stbi_set_flip_vertically_on_load(true);
         int width = 0, height = 0, channels = 0;
         unsigned char *image_data = stbi_load(file.string().c_str(), &width, &height, &channels, 4);
         if (!image_data)
           throw std::runtime_error(std::format("Could not load texture image file '{}'", file.string()));
         binary_data image_vector(image_data, image_data + (width * height * channels));
         stbi_image_free(image_data);
         auto &[frame_width, frame_height, frame_groups] = texture_configs.at(file.filename());
         return {image_vector, {width, height, channels, {frame_width, frame_height, frame_groups}}};
       }
     },
     [](const auto &name, const auto &data)
     {
       std::vector<std::string> results = {};
       auto &[data_vector, texture_config] = data;

       std::string data_vector_result = {};
       for (std::size_t index = 0; index < data_vector.size(); ++index)
       {
         data_vector_result += csb::unsigned_char_to_hex(data_vector[index]);
         if (index < data_vector.size() - 1)
         {
           data_vector_result += ",";
           if ((index + 1) % 16 == 0)
             data_vector_result += "\n    ";
           else
             data_vector_result += " ";
         }
       }
       results.push_back(data_vector_result);
       results.push_back(std::to_string(data_vector.size()));

       auto &[width, height, channels, texture] = texture_config;
       auto &[frame_width, frame_height, frame_groups] = texture;
       if (width == 0 || height == 0 || channels == 0 || frame_width == 0 || frame_height == 0 || frame_groups.empty())
         return results;
       const int frames_per_row = width / frame_width;
       const int frames_per_column = height / frame_height;
       std::string groups_result = {};
       for (const auto &frame_group : frame_groups)
       {
         const auto &[group_name, start_frame, end_frame] = frame_group;
         groups_result += std::format("  static constexpr std::array<const compiled_texture::frame_data::group::frame, "
                                      "{}> {}_{}_frames = {{\n    {{",
                                      end_frame - start_frame + 1, name, group_name);
         for (int frame_index = start_frame - 1; frame_index < end_frame; ++frame_index)
         {
           const int frame_x = frame_index % frames_per_row;
           const int frame_y = (frames_per_column - 1) - (frame_index / frames_per_row);
           const float top = static_cast<float>((frame_y + 1) * frame_height) / static_cast<float>(height);
           const float left = static_cast<float>(frame_x * frame_width) / static_cast<float>(width);
           const float bottom = static_cast<float>(frame_y * frame_height) / static_cast<float>(height);
           const float right = static_cast<float>((frame_x + 1) * frame_width) / static_cast<float>(width);
           groups_result += std::format("{{{:#g}f, {:#g}f, {:#g}f, {:#g}f}}", top, left, bottom, right);
           if (frame_index < end_frame - 1) groups_result += ",\n    ";
         }
         groups_result += "}};\n";
       }
       groups_result += std::format("  static constexpr std::array<std::pair<std::string_view, "
                                    "compiled_texture::frame_data::group>, {}> {}_groups = {{\n    {{",
                                    frame_groups.size(), name);
       auto sorted_frame_groups = frame_groups;
       std::sort(sorted_frame_groups.begin(), sorted_frame_groups.end(),
                 [](const auto &a, const auto &b) { return std::get<0>(a) < std::get<0>(b); });
       for (const auto &frame_group : sorted_frame_groups)
       {
         const auto &[group_name, start_frame, end_frame] = frame_group;
         groups_result +=
           std::format("{{\"{}\", {{{}, {}, {}_{}_frames}}}}", group_name, start_frame, end_frame, name, group_name);
         if (&frame_group != &sorted_frame_groups.back()) groups_result += ",\n     ";
       }
       groups_result += "}};";
       results.push_back(groups_result);

       return results;
     }},
    {[](const auto &files)
     {
       std::string result = {};
       for (const auto &[file, name, data] : files)
       {
         if (file.extension() == ".spv")
           result += std::format("  extern const compiled_shader {};\n", name);
         else
           result += std::format("  extern const compiled_texture {};\n", name);
       }
       return result + "}";
     },
     [](const auto &files)
     {
       std::string result = {};
       for (const auto &[file, name, data] : files)
       {
         if (file.extension() == ".spv")
         {
           const auto &shader_data = std::get<0>(data);
           result +=
             std::format("  const compiled_shader {} = {{\n    {}_data,\n    {}}};\n", name, name, shader_data.size());
         }
         else
         {
           const auto &[width, height, channels, texture] = std::get<1>(data);
           const auto &[frame_width, frame_height, frame_groups] = texture;
           result += std::format("  const compiled_texture {} = {{\n    {}_image,\n    "
                                 "{{{}, {}, {}}},\n    {{{}, {}, {}_groups}}}};\n",
                                 name, name, width, height, channels, frame_width, frame_height, name);
         }
       }
       return result + "}";
     }},
    [](const auto &file) { return file.extension() == ".spv" || file.extension() == ".png"; },
    csb::files_from({"build/shader", "program/texture"}),
    {"program/include/resource.hpp", "program/source/resource.cpp"});

  if (!csb::is_subproject)
  {
    csb::clang_format("21.1.1", {"program/include/resource.hpp", "program/source/resource.cpp"});
    csb::generate_compile_commands();
  }

  csb::compile();
  csb::link();
  return CSB_SUCCESS;
}

int run()
{
  csb::run_target();
  return CSB_SUCCESS;
}

CSB_MAIN()
